"""
Consolidador de cotizaciones de seguros.

Este m√≥dulo se encarga de crear un archivo Excel consolidado con los resultados
de las cotizaciones de Sura y Allianz una vez que ambas automatizaciones han finalizado.
"""

import os
import re
import logging
from datetime import datetime
from typing import Dict, Any, Optional, List, Tuple
from pathlib import Path
import pandas as pd

from ..config.client_config import ClientConfig
from ..config.formulas_config import FormulasConfig
from ..core.logger_factory import LoggerFactory


class CotizacionConsolidator:
    def extract_allianz_plans_from_logs(self) -> Dict[str, str]:
        """Extrae los valores de los planes de Allianz desde los logs de la automatizaci√≥n."""
        self.logger.info("üìä Extrayendo valores de planes de Allianz desde logs...")
        plans = {
            'Autos Esencial': 'No encontrado',
            'Autos Plus': 'No encontrado',
            'Autos Llave en Mano': 'No encontrado',
            'Autos Esencial + Totales': 'No encontrado'
        }
        try:
            allianz_log_path = self.base_path / "LOGS" / "allianz" / "allianz.log"
            if not allianz_log_path.exists():
                self.logger.warning("No se encontr√≥ el archivo de log de Allianz")
                return plans
            with open(allianz_log_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            recent_lines = lines[-500:] if len(lines) > 500 else lines
            patterns = {
                'Autos Esencial': r'\[EXTRACCI√ìN\] Autos Esencial: ([0-9.,]+)',
                'Autos Plus': r'\[EXTRACCI√ìN\] Autos Plus: ([0-9.,]+)',
                'Autos Llave en Mano': r'\[EXTRACCI√ìN\] Autos Llave en Mano: ([0-9.,]+)'
            }
            for plan_name, pattern in patterns.items():
                for line in reversed(recent_lines):
                    match = re.search(pattern, line)
                    if match:
                        value = match.group(1).replace('.', '').replace(',', '.')
                        try:
                            numeric_value = float(value)
                            plans[plan_name] = f"{numeric_value:,.2f}".replace(",", "_").replace(".", ",").replace("_", ".")
                        except Exception:
                            plans[plan_name] = match.group(1)
                        break
            # Autos Esencial + Totales: suma de los otros tres si todos existen
            try:
                if all(plans[k] != 'No encontrado' for k in ['Autos Esencial', 'Autos Plus', 'Autos Llave en Mano']):
                    total = sum(float(plans[k].replace('.', '').replace(',', '.')) for k in ['Autos Esencial', 'Autos Plus', 'Autos Llave en Mano'])
                    plans['Autos Esencial + Totales'] = f"{total:,.2f}".replace(",", "_").replace(".", ",").replace("_", ".")
            except Exception:
                pass
            return plans
        except Exception as e:
            self.logger.error(f"Error extrayendo valores de Allianz desde logs: {e}")
            return plans
    """Consolidador de cotizaciones de Sura y Allianz."""
    
    def __init__(self):
        self.logger = LoggerFactory.create_logger('consolidator')
        self.base_path = Path(__file__).parent.parent.parent
        self.consolidados_path = self.base_path / "Consolidados"
        self.downloads_path = self.base_path / "downloads"
        
        # Inicializar configuraci√≥n de f√≥rmulas
        self.formulas_config = FormulasConfig()
        
        # Crear directorio si no existe
        self.consolidados_path.mkdir(exist_ok=True)
        
    def generate_filename(self) -> str:
        """Genera un nombre √∫nico para el archivo basado en la fecha actual."""
        today = datetime.now()
        base_name = f"Cotizacion{today.strftime('%d-%m-%y')}"
        extension = ".xlsx"
        
        # Verificar si el archivo ya existe y generar nombre √∫nico
        counter = 0
        filename = f"{base_name}{extension}"
        full_path = self.consolidados_path / filename
        
        while full_path.exists():
            counter += 1
            filename = f"{base_name}({counter}){extension}"
            full_path = self.consolidados_path / filename
            
        return filename
    
    def extract_sura_data(self) -> Dict[str, Any]:
        """Extrae los datos de configuraci√≥n de Sura."""
        self.logger.info("Extrayendo datos de configuraci√≥n de Sura...")
        
        sura_data = {
            'CLIENT_DOCUMENT_NUMBER': ClientConfig.CLIENT_DOCUMENT_NUMBER,
            'CLIENT_DOCUMENT_TYPE': ClientConfig.get_client_document_type('sura'),
            'CLIENT_FIRST_NAME': ClientConfig.CLIENT_FIRST_NAME,
            'CLIENT_SECOND_NAME': ClientConfig.CLIENT_SECOND_NAME,
            'CLIENT_FIRST_LASTNAME': ClientConfig.CLIENT_FIRST_LASTNAME,
            'CLIENT_SECOND_LASTNAME': ClientConfig.CLIENT_SECOND_LASTNAME,
            'CLIENT_BIRTH_DATE': ClientConfig.get_client_birth_date('sura'),
            'CLIENT_GENDER': ClientConfig.CLIENT_GENDER,
            'CLIENT_PHONE': getattr(ClientConfig, 'CLIENT_PHONE', ''),
            'CLIENT_EMAIL': getattr(ClientConfig, 'CLIENT_EMAIL', ''),
            'CLIENT_EMAIL_TYPE': getattr(ClientConfig, 'CLIENT_EMAIL_TYPE', ''),
            'CLIENT_OCCUPATION': ClientConfig.CLIENT_OCCUPATION,
            'CLIENT_ADDRESS': ClientConfig.CLIENT_ADDRESS,
            'CLIENT_PHONE_WORK': ClientConfig.CLIENT_PHONE_WORK,
            'CLIENT_CITY': ClientConfig.get_client_city('sura'),
            'POLIZA_NUMBER': ClientConfig.get_policy_number('sura'),
            'VEHICLE_CATEGORY': ClientConfig.VEHICLE_CATEGORY,
            'VEHICLE_STATE': ClientConfig.VEHICLE_STATE,
            'VEHICLE_MODEL_YEAR': ClientConfig.VEHICLE_MODEL_YEAR,
            'VEHICLE_BRAND': ClientConfig.VEHICLE_BRAND,
            'VEHICLE_REFERENCE': ClientConfig.VEHICLE_REFERENCE,
            'VEHICLE_FULL_REFERENCE': ClientConfig.VEHICLE_FULL_REFERENCE,
        }
        
        return sura_data
    
    def get_valor_asegurado(self) -> Optional[str]:
        """
        Obtiene el valor asegurado seg√∫n el tipo de cliente.
        Para clientes nuevos: desde ClientConfig
        Para clientes usados: desde ClientConfig (ya extra√≠do por Allianz)
        """
        try:
            # Obtener valor desde ClientConfig (ya sea ingresado manualmente o extra√≠do)
            valor = ClientConfig.get_vehicle_insured_value()
            
            if valor and valor.strip():
                # Limpiar el valor (quitar caracteres no num√©ricos excepto comas y puntos)
                valor_limpio = ''.join(c for c in valor if c.isdigit() or c in '.,')
                return valor_limpio
            else:
                self.logger.warning("‚ö†Ô∏è No se encontr√≥ valor asegurado en la configuraci√≥n")
                return None
                
        except Exception as e:
            self.logger.error(f"‚ùå Error obteniendo valor asegurado: {e}")
            return None
    
    def calculate_bolivar_solidaria_plans(self) -> Dict[str, str]:
        """Calcula las cotizaciones de Bol√≠var y Solidaria usando las f√≥rmulas configuradas."""
        self.logger.info("üí∞ Calculando cotizaciones de Bol√≠var y Solidaria...")
        
        plans = {
            'Bol√≠var': 'No calculado',
            'Solidaria': 'No calculado'
        }
        
        # Obtener valor asegurado
        valor_asegurado = self.get_valor_asegurado()
        if not valor_asegurado:
            self.logger.warning("‚ö†Ô∏è No se puede calcular Bol√≠var y Solidaria: valor asegurado no disponible")
            return plans
        
        self.logger.info(f"üí∞ Calculando con valor asegurado: {valor_asegurado}")
        
        # Calcular Bol√≠var
        try:
            bolivar_result = self.formulas_config.calculate_cotizacion('bolivar', valor_asegurado)
            if bolivar_result is not None:
                plans['Bol√≠var'] = f"{bolivar_result:,.0f}".replace(",", ".")
                self.logger.info(f"‚úÖ Bol√≠var calculado: ${plans['Bol√≠var']}")
            else:
                self.logger.warning("‚ö†Ô∏è Error calculando cotizaci√≥n de Bol√≠var")
        except Exception as e:
            self.logger.error(f"‚ùå Error calculando Bol√≠var: {e}")
        
        # Calcular Solidaria
        try:
            solidaria_result = self.formulas_config.calculate_cotizacion('solidaria', valor_asegurado)
            if solidaria_result is not None:
                plans['Solidaria'] = f"{solidaria_result:,.0f}".replace(",", ".")
                self.logger.info(f"‚úÖ Solidaria calculado: ${plans['Solidaria']}")
            else:
                self.logger.warning("‚ö†Ô∏è Error calculando cotizaci√≥n de Solidaria")
        except Exception as e:
            self.logger.error(f"‚ùå Error calculando Solidaria: {e}")
        
        return plans
    
    def get_latest_sura_pdf(self) -> Optional[Path]:
        """Obtiene el PDF m√°s reciente de Sura."""
        sura_downloads = self.downloads_path / "sura"
        
        if not sura_downloads.exists():
            self.logger.warning("Directorio de descargas de Sura no encontrado")
            return None
            
        # Buscar archivos PDF de Sura
        pdf_files = list(sura_downloads.glob("Cotizacion_Sura_*.pdf"))
        
        if not pdf_files:
            self.logger.warning("No se encontraron PDFs de Sura")
            return None
            
        # Ordenar por fecha de modificaci√≥n (m√°s reciente primero)
        pdf_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        self.logger.info(f"PDF m√°s reciente de Sura: {pdf_files[0].name}")
        return pdf_files[0]
    
    def get_latest_allianz_pdf(self) -> Optional[Path]:
        """Obtiene el PDF m√°s reciente de Allianz."""
        allianz_downloads = self.downloads_path / "allianz"
        
        if not allianz_downloads.exists():
            self.logger.warning("Directorio de descargas de Allianz no encontrado")
            return None
            
        # Buscar archivos PDF de Allianz
        pdf_files = list(allianz_downloads.glob("Cotizacion_Allianz_*.pdf"))
        
        if not pdf_files:
            self.logger.warning("No se encontraron PDFs de Allianz")
            return None
            
        # Ordenar por fecha de modificaci√≥n (m√°s reciente primero)
        pdf_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
        
        self.logger.info(f"PDF m√°s reciente de Allianz: {pdf_files[0].name}")
        return pdf_files[0]
    
    def extract_sura_plans_from_logs(self) -> Dict[str, str]:
        """Extrae los valores de los planes de Sura desde los logs de la automatizaci√≥n, incluyendo P√©rdida Parcial 10-1 SMLMV."""
        self.logger.info("üìä Extrayendo valores de planes de Sura desde logs...")
        plans = {
            'Plan Autos Global': 'No encontrado',
            'P√©rdida Parcial 10-1 SMLMV': 'No encontrado',
            'Plan Autos Clasico': 'No encontrado'
        }
        try:
            sura_log_path = self.base_path / "LOGS" / "sura" / "sura.log"
            if not sura_log_path.exists():
                self.logger.warning("No se encontr√≥ el archivo de log de Sura")
                return plans
            with open(sura_log_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            recent_lines = lines[-500:] if len(lines) > 500 else lines
            # Patrones para buscar los valores en los logs
            patterns = {
                'Plan Autos Global': [
                    r'Global:\s*\$([0-9,.]+)',
                    r'Prima Plan Global:\s*\$([0-9,.]+)',
                    r'prima_global[\'\"]\s*:\s*([0-9,.]+)'
                ],
                'P√©rdida Parcial 10-1 SMLMV': [
                    r'tras 10-1 SMLMV:\s*\$([0-9,.]+)',
                    r'P√©rdida Parcial 10-1 SMLMV:\s*\$([0-9,.]+)',
                    r'prima_10_1[\'\"]\s*:\s*([0-9,.]+)'
                ],
                'Plan Autos Clasico': [
                    r'Cl√°sico:\s*\$([0-9,.]+)',
                    r'Prima Plan Autos Cl√°sico:\s*\$([0-9,.]+)',
                    r'prima_clasico[\'\"]\s*:\s*([0-9,.]+)'
                ]
            }
            for plan_name, plan_patterns in patterns.items():
                for line in reversed(recent_lines):
                    for pattern in plan_patterns:
                        match = re.search(pattern, line, re.IGNORECASE)
                        if match:
                            value = match.group(1).replace(',', '').replace('.', '')
                            if value.isdigit():
                                plans[plan_name] = f"{int(value):,}".replace(",", ".")
                                self.logger.info(f"‚úÖ Encontrado {plan_name}: ${plans[plan_name]}")
                                break
                    if plans[plan_name] != 'No encontrado':
                        break
            return plans
        except Exception as e:
            self.logger.error(f"Error extrayendo valores de Sura desde logs: {e}")
            return plans

    def extract_sura_plans_from_pdf(self, pdf_path: Path) -> Dict[str, str]:
        """Extrae los valores de los planes de Sura del PDF (m√©todo de respaldo)."""
        self.logger.info("üìÑ Extrayendo valores de Sura desde PDF (m√©todo de respaldo)...")
        text = self.extract_text_from_pdf(pdf_path)
        
        plans = {
            'Plan Autos Global': 'No encontrado',
            'Plan Autos Clasico': 'No encontrado'
        }
        
        # Patrones para buscar los valores de los planes
        patterns = {
            'Plan Autos Global': [
                r'Plan\s+Autos\s+Global[:\s]*\$?\s*([0-9.,]+)',
                r'Global[:\s]*\$?\s*([0-9.,]+)',
                r'GLOBAL[:\s]*\$?\s*([0-9.,]+)'
            ],
            'Plan Autos Clasico': [
                r'Plan\s+Autos\s+Cl[a√°]sico[:\s]*\$?\s*([0-9.,]+)',
                r'Cl[a√°]sico[:\s]*\$?\s*([0-9.,]+)',
                r'CLASICO[:\s]*\$?\s*([0-9.,]+)'
            ]
        }
        
        for plan_name, plan_patterns in patterns.items():
            for pattern in plan_patterns:
                matches = re.finditer(pattern, text, re.IGNORECASE)
                for match in matches:
                    value = match.group(1).replace(',', '').replace('.', '')
                    if value.isdigit() and len(value) >= 3:
                        plans[plan_name] = f"{int(value):,}"
                        break
            if plans[plan_name] != 'No encontrado':
                break
        
        return plans
    
    def extract_allianz_plans_from_pdf(self, pdf_path: Path) -> Dict[str, str]:
        """Extrae los valores de los planes de Allianz del PDF."""
        text = self.extract_text_from_pdf(pdf_path)
        
        plans = {
            'Autos Esencial': 'No encontrado',
            'Autos Esencial + Totales': 'No encontrado', 
            'Autos Plus': 'No encontrado',
            'Autos Llave en Mano': 'No encontrado'
        }
        
        self.logger.info("üîç Buscando tabla de valores de Allianz en PDF...")
        
        # Buscar la tabla con los valores anuales - patr√≥n mejorado
        anual_patterns = [
            r'Anual\s*-?\s*Prima\s*Total\s*Vigencia\s*([\d.,]+)\s*([\d.,]+)\s*([\d.,]+)\s*([\d.,]+)',
            r'Prima\s*Total\s*Vigencia\s*Anual[:\s]*([\d.,]+)\s*([\d.,]+)\s*([\d.,]+)\s*([\d.,]+)',
            r'ANUAL.*?PRIMA.*?TOTAL.*?VIGENCIA[:\s]*([\d.,]+)\s*([\d.,]+)\s*([\d.,]+)\s*([\d.,]+)'
        ]
        
        # Intentar encontrar la tabla completa
        found_table = False
        for pattern in anual_patterns:
            match = re.search(pattern, text, re.IGNORECASE | re.DOTALL)
            if match:
                self.logger.info("‚úÖ Tabla de valores encontrada en PDF")
                values = [match.group(i) for i in range(1, 5)]
                plan_names = list(plans.keys())
                
                for i, value in enumerate(values):
                    if i < len(plan_names):
                        # Limpiar el valor (formato colombiano: 311.572,10)
                        clean_value = value.replace('.', '').replace(',', '.')
                        try:
                            # Convertir a n√∫mero y formatear
                            numeric_value = float(clean_value)
                            plans[plan_names[i]] = f"{int(numeric_value):,}"
                            self.logger.info(f"‚úÖ {plan_names[i]}: ${plans[plan_names[i]]}")
                        except ValueError:
                            self.logger.warning(f"‚ö†Ô∏è No se pudo convertir valor: {value}")
                            plans[plan_names[i]] = value
                found_table = True
                break
        
        # Si no se encuentra la tabla completa, buscar valores individuales
        if not found_table:
            self.logger.info("üîç Tabla completa no encontrada, buscando valores individuales...")
            individual_patterns = {
                'Autos Esencial': [
                    r'Autos\s+Esencial(?!\s*\+)[^0-9]*?([0-9.,]+)',
                    r'Esencial(?!\s*\+)[^0-9]*?([0-9.,]+)',
                    r'ESENCIAL(?!\s*\+)[^0-9]*?([0-9.,]+)'
                ],
                'Autos Esencial + Totales': [
                    r'Autos\s+Esencial\s*\+\s*Totales[^0-9]*?([0-9.,]+)',
                    r'Esencial\s*\+\s*Totales[^0-9]*?([0-9.,]+)',
                    r'ESENCIAL\s*\+\s*TOTALES[^0-9]*?([0-9.,]+)'
                ],
                'Autos Plus': [
                    r'Autos\s+Plus[^0-9]*?([0-9.,]+)',
                    r'Plus[^0-9]*?([0-9.,]+)',
                    r'PLUS[^0-9]*?([0-9.,]+)'
                ],
                'Autos Llave en Mano': [
                    r'Autos\s+Llave\s+en\s+Mano[^0-9]*?([0-9.,]+)',
                    r'Llave\s+en\s+Mano[^0-9]*?([0-9.,]+)',
                    r'LLAVE\s+EN\s+MANO[^0-9]*?([0-9.,]+)'
                ]
            }
            
            for plan_name, plan_patterns in individual_patterns.items():
                for pattern in plan_patterns:
                    matches = re.finditer(pattern, text, re.IGNORECASE)
                    for match in matches:
                        value = match.group(1)
                        # Limpiar y validar valor
                        clean_value = value.replace('.', '').replace(',', '.')
                        try:
                            if '.' in clean_value:
                                numeric_value = float(clean_value)
                                plans[plan_name] = f"{int(numeric_value):,}"
                                self.logger.info(f"‚úÖ {plan_name}: ${plans[plan_name]}")
                                break
                        except ValueError:
                            continue
                if plans[plan_name] != 'No encontrado':
                    break
        
        self.logger.info(f"Planes extra√≠dos de Allianz: {plans}")
        return plans
    
    def create_excel_report(self, sura_data: Dict[str, Any], sura_plans: Dict[str, str], 
                          allianz_plans: Dict[str, str], bolivar_solidaria_plans: Dict[str, str]) -> str:
        """Crea el reporte Excel consolidado con estructura mejorada en una sola hoja."""
        filename = self.generate_filename()
        file_path = self.consolidados_path / filename
        
        self.logger.info(f"üìä Creando reporte Excel consolidado: {filename}")
        
        # Obtener valor asegurado
        valor_asegurado = self.get_valor_asegurado()
        valor_asegurado_formatted = f"${valor_asegurado}" if valor_asegurado else "No disponible"
        
        # Crear lista de filas para el Excel consolidado
        rows = []
        
        # === SECCI√ìN 1: DATOS DEL CLIENTE ===
        rows.append({'Categor√≠a': 'DATOS DEL CLIENTE', 'Campo': '', 'Valor': ''})
        client_fields = [
            ('N√∫mero de Documento', 'CLIENT_DOCUMENT_NUMBER'),
            ('Tipo de Documento', 'CLIENT_DOCUMENT_TYPE'),
            ('Primer Nombre', 'CLIENT_FIRST_NAME'),
            ('Segundo Nombre', 'CLIENT_SECOND_NAME'),
            ('Primer Apellido', 'CLIENT_FIRST_LASTNAME'),
            ('Segundo Apellido', 'CLIENT_SECOND_LASTNAME'),
            ('Fecha de Nacimiento', 'CLIENT_BIRTH_DATE'),
            ('G√©nero', 'CLIENT_GENDER'),
            ('Ocupaci√≥n', 'CLIENT_OCCUPATION'),
            ('Tel√©fono', 'CLIENT_PHONE'),
            ('Email', 'CLIENT_EMAIL')
        ]
        
        for display_name, config_key in client_fields:
            value = sura_data.get(config_key, 'No disponible')
            rows.append({'Categor√≠a': '', 'Campo': display_name, 'Valor': value})
        
        # === SECCI√ìN 2: DATOS DE DIRECCI√ìN ===
        rows.append({'Categor√≠a': '', 'Campo': '', 'Valor': ''})
        rows.append({'Categor√≠a': 'DATOS DE DIRECCI√ìN', 'Campo': '', 'Valor': ''})
        address_fields = [
            ('Direcci√≥n', 'CLIENT_ADDRESS'),
            ('Tel√©fono de Trabajo', 'CLIENT_PHONE_WORK'),
            ('Ciudad', 'CLIENT_CITY')
        ]
        
        for display_name, config_key in address_fields:
            value = sura_data.get(config_key, 'No disponible')
            rows.append({'Categor√≠a': '', 'Campo': display_name, 'Valor': value})
        
        # === SECCI√ìN 3: DATOS DEL VEH√çCULO ===
        rows.append({'Categor√≠a': '', 'Campo': '', 'Valor': ''})
        rows.append({'Categor√≠a': 'DATOS DEL VEH√çCULO', 'Campo': '', 'Valor': ''})
        vehicle_fields = [
            ('Categor√≠a', 'VEHICLE_CATEGORY'),
            ('Estado', 'VEHICLE_STATE'),
            ('A√±o del Modelo', 'VEHICLE_MODEL_YEAR'),
            ('Marca', 'VEHICLE_BRAND'),
            ('Referencia', 'VEHICLE_REFERENCE'),
            ('Referencia Completa', 'VEHICLE_FULL_REFERENCE')
        ]
        
        for display_name, config_key in vehicle_fields:
            value = sura_data.get(config_key, 'No disponible')
            rows.append({'Categor√≠a': '', 'Campo': display_name, 'Valor': value})
        
        # A√±adir valor asegurado
        rows.append({'Categor√≠a': '', 'Campo': 'Valor Asegurado', 'Valor': valor_asegurado_formatted})
        
        # === SECCI√ìN 4: COTIZACIONES ===
        rows.append({'Categor√≠a': '', 'Campo': '', 'Valor': ''})
        rows.append({'Categor√≠a': 'COTIZACIONES POR ASEGURADORA', 'Campo': '', 'Valor': ''})
        
        # SURA
        rows.append({'Categor√≠a': '', 'Campo': '', 'Valor': ''})
        rows.append({'Categor√≠a': 'SURA', 'Campo': '', 'Valor': ''})
        
        # Exportar seg√∫n tipo de veh√≠culo
        if sura_data.get('VEHICLE_STATE', '').lower() == 'usado':
            # Usado: mostrar los 3 valores
            sura_plan_map = [
                ("Plan Autos Global", sura_plans.get("Plan Autos Global")),
                ("P√©rdida Parcial 10-1 SMLMV", sura_plans.get("P√©rdida Parcial 10-1 SMLMV")),
                ("Plan Autos Cl√°sico", sura_plans.get("Plan Autos Clasico")),
            ]
        else:
            # Nuevo: solo global y cl√°sico
            sura_plan_map = [
                ("Plan Autos Global", sura_plans.get("Plan Autos Global")),
                ("Plan Autos Cl√°sico", sura_plans.get("Plan Autos Clasico")),
            ]
        
        for plan_name, plan_value in sura_plan_map:
            formatted_value = f"${plan_value}" if plan_value not in [None, 'No encontrado'] else (plan_value if plan_value is not None else 'No encontrado')
            rows.append({'Categor√≠a': '', 'Campo': plan_name, 'Valor': formatted_value})
        
        # ALLIANZ
        rows.append({'Categor√≠a': '', 'Campo': '', 'Valor': ''})
        rows.append({'Categor√≠a': 'ALLIANZ', 'Campo': '', 'Valor': ''})
        allianz_plan_names = [
            'Autos Esencial',
            'Autos Esencial + Totales',
            'Autos Plus',
            'Autos Llave en Mano'
        ]
        
        for plan_name in allianz_plan_names:
            plan_value = allianz_plans.get(plan_name, 'No encontrado')
            formatted_value = f"${plan_value}" if plan_value != 'No encontrado' else plan_value
            rows.append({'Categor√≠a': '', 'Campo': plan_name, 'Valor': formatted_value})
        
        # BOL√çVAR Y SOLIDARIA
        rows.append({'Categor√≠a': '', 'Campo': '', 'Valor': ''})
        rows.append({'Categor√≠a': 'BOL√çVAR', 'Campo': '', 'Valor': ''})
        bolivar_value = bolivar_solidaria_plans.get('Bol√≠var', 'No calculado')
        formatted_bolivar = f"${bolivar_value}" if bolivar_value != 'No calculado' else bolivar_value
        rows.append({'Categor√≠a': '', 'Campo': 'Cotizaci√≥n Calculada', 'Valor': formatted_bolivar})
        
        rows.append({'Categor√≠a': '', 'Campo': '', 'Valor': ''})
        rows.append({'Categor√≠a': 'SOLIDARIA', 'Campo': '', 'Valor': ''})
        solidaria_value = bolivar_solidaria_plans.get('Solidaria', 'No calculado')
        formatted_solidaria = f"${solidaria_value}" if solidaria_value != 'No calculado' else solidaria_value
        rows.append({'Categor√≠a': '', 'Campo': 'Cotizaci√≥n Calculada', 'Valor': formatted_solidaria})
        
        # Crear DataFrame
        df = pd.DataFrame(rows)
        
        # Escribir a Excel con una sola hoja
        with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
            df.to_excel(writer, sheet_name='COTIZACION_CONSOLIDADA', index=False)
        
        self.logger.info(f"üìä Reporte Excel consolidado creado exitosamente: {filename}")
        return str(file_path)
    
    def consolidate_with_failures(self, automation_results: Dict[str, bool]) -> bool:
        """
        Ejecuta el proceso de consolidaci√≥n incluso si algunas automatizaciones fallaron.
        
        Args:
            automation_results: Dict con resultados de automatizaciones {'allianz': True/False, 'sura': True/False}
        """
        try:
            self.logger.info("Iniciando proceso de consolidaci√≥n con posibles fallos...")
            self.logger.info(f"Resultados de automatizaci√≥n: {automation_results}")
            
            # 1. Extraer datos de configuraci√≥n de Sura (siempre intentar)
            sura_data = self.extract_sura_data()
            
            # 2. Obtener PDFs m√°s recientes
            sura_pdf = self.get_latest_sura_pdf()
            allianz_pdf = self.get_latest_allianz_pdf()
            
            # 3. Extraer planes seg√∫n el √©xito de cada automatizaci√≥n
            if automation_results.get('sura', False):
                # Sura exitosa: extraer normalmente
                sura_plans = self.extract_sura_plans_from_logs()
                
                # Si no se encontraron en logs, intentar desde PDF
                if all(plan == 'No encontrado' for plan in sura_plans.values()) and sura_pdf:
                    self.logger.info("üìÑ No se encontraron valores en logs, intentando desde PDF...")
                    sura_plans = self.extract_sura_plans_from_pdf(sura_pdf)
            else:
                # Sura fall√≥: llenar con "FALL√ì"
                self.logger.warning("‚ùå Sura fall√≥, llenando planes con 'FALL√ì'")
                sura_plans = {
                    'A TODO RIESGO C/D 15%': 'FALL√ì',
                    'A TODO RIESGO C/D 10%': 'FALL√ì',
                    'RESPONSABILIDAD CIVIL + PT + HU': 'FALL√ì'
                }
            
            if automation_results.get('allianz', False):
                # Allianz exitosa: extraer normalmente
                allianz_plans = self.extract_allianz_plans_from_logs()
            else:
                # Allianz fall√≥: llenar con "FALL√ì"
                self.logger.warning("‚ùå Allianz fall√≥, llenando planes con 'FALL√ì'")
                allianz_plans = {
                    'Autos Esencial': 'FALL√ì',
                    'Autos Plus': 'FALL√ì',
                    'Autos Llave en Mano': 'FALL√ì',
                    'Autos Esencial + Totales': 'FALL√ì'
                }
            
            self.logger.info(f"Planes de Sura: {sura_plans}")
            self.logger.info(f"Planes de Allianz: {allianz_plans}")
            
            # 4. Calcular cotizaciones de Bol√≠var y Solidaria (siempre posible)
            bolivar_solidaria_plans = self.calculate_bolivar_solidaria_plans()
            
            # 5. Crear reporte Excel consolidado
            excel_path = self.create_excel_report(sura_data, sura_plans, allianz_plans, bolivar_solidaria_plans)
            
            self.logger.info(f"Consolidaci√≥n con fallos completada. Archivo: {excel_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error durante la consolidaci√≥n con fallos: {e}")
            return False

    def consolidate(self) -> bool:
        """Ejecuta el proceso de consolidaci√≥n completo."""
        try:
            self.logger.info("Iniciando proceso de consolidaci√≥n...")
            
            # 1. Extraer datos de configuraci√≥n de Sura
            sura_data = self.extract_sura_data()
            
            # 2. Obtener PDFs m√°s recientes
            sura_pdf = self.get_latest_sura_pdf()
            allianz_pdf = self.get_latest_allianz_pdf()
            
            # 3. Extraer planes de Sura (primero desde logs, luego PDF como respaldo)
            sura_plans = self.extract_sura_plans_from_logs()
            
            # Si no se encontraron en logs, intentar desde PDF
            if all(plan == 'No encontrado' for plan in sura_plans.values()) and sura_pdf:
                self.logger.info("üìÑ No se encontraron valores en logs, intentando desde PDF...")
                sura_plans = self.extract_sura_plans_from_pdf(sura_pdf)
            elif sura_pdf is None:
                self.logger.warning("No se encontr√≥ PDF de Sura para extracci√≥n")
            
            self.logger.info(f"Planes de Sura: {sura_plans}")
            
            # 4. Extraer planes de Allianz desde logs (no PDF)
            allianz_plans = self.extract_allianz_plans_from_logs()
            
            # 5. Calcular cotizaciones de Bol√≠var y Solidaria
            bolivar_solidaria_plans = self.calculate_bolivar_solidaria_plans()
            
            # 6. Crear reporte Excel consolidado
            excel_path = self.create_excel_report(sura_data, sura_plans, allianz_plans, bolivar_solidaria_plans)
            
            self.logger.info(f"Consolidaci√≥n completada exitosamente. Archivo: {excel_path}")
            return True
            
        except Exception as e:
            self.logger.error(f"Error durante la consolidaci√≥n: {e}")
            return False


def main():
    """Funci√≥n principal para ejecutar la consolidaci√≥n."""
    consolidator = CotizacionConsolidator()
    success = consolidator.consolidate()
    
    if success:
        print("‚úÖ Consolidaci√≥n completada exitosamente")
        return 0
    else:
        print("‚ùå Error durante la consolidaci√≥n")
        return 1


if __name__ == "__main__":
    import sys
    sys.exit(main())
