"""P√°gina de login espec√≠fica para Sura."""

from playwright.async_api import Page
from ....shared.base_page import BasePage
from ....config.sura_config import SuraConfig
from ....core.constants import Constants

class LoginPage(BasePage):
    """P√°gina de login con sus selectores y m√©todos espec√≠ficos para Sura."""
    
    # Selectores espec√≠ficos de Sura
    TIPO_DOCUMENTO_SELECT = "select[name='ctl00$ContentMain$suraType']"
    NUMERO_DOCUMENTO_INPUT = "input[name='suraName']"
    CONTRASENA_INPUT = "input[name='suraPassword']"
    SUBMIT_BUTTON = "input[type='button'][id='session-internet']"
    
    # Selectores del teclado virtual
    VIRTUAL_KEYBOARD = ".ui-keyboard"
    KEYBOARD_ACCEPT = "button[data-value='‚úî']"
    KEYBOARD_BACKSPACE = "button[data-value='‚å´']"
    
    # JavaScript optimizado para hacer clic en d√≠gitos del teclado virtual
    _CLICK_DIGIT_JS = """
    (digit) => {
        const keyboard = document.querySelector('.ui-keyboard');
        const button = keyboard ? keyboard.querySelector(`button[data-value="${digit}"]`) : null;
        
        if (button) {
            const mouseDownEvent = new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window });
            const mouseUpEvent = new MouseEvent('mouseup', { bubbles: true, cancelable: true, view: window });
            const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });
            
            button.dispatchEvent(mouseDownEvent);
            setTimeout(() => {
                button.dispatchEvent(mouseUpEvent);
                button.dispatchEvent(clickEvent);
            }, 50);
            
            return true;
        }
        return false;
    }
    """
    
    # JavaScript para verificar el valor actual en el teclado virtual
    _GET_KEYBOARD_VALUE_JS = """
    () => {
        const keyboard = document.querySelector('.ui-keyboard');
        const inputInKeyboard = keyboard ? keyboard.querySelector('input[name="suraPassword"]') : null;
        return inputInKeyboard ? inputInKeyboard.value : '';
    }
    """

    def __init__(self, page: Page):
        super().__init__(page, 'sura')
        self.config = SuraConfig()    
        
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    async def _get_value(self, selector: str) -> str:
        """Devuelve el .value de un elemento dado su selector CSS."""
        return await self.get_element_value(selector, "value")

    async def _is_password_entered(self) -> bool:
        """Comprueba si el campo de contrase√±a ya tiene valor."""
        value = await self._get_value(self.CONTRASENA_INPUT)
        return bool(value)
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    async def navigate_to_login(self) -> bool:
        """Navega a la p√°gina de login de Sura o detecta si ya est√° logueado."""
        self.logger.info("üåê Navegando a p√°gina de login Sura...")
        try:
            await self.page.goto(self.config.LOGIN_URL)
            
            # Esperar un poco para que la p√°gina cargue completamente
            await self.page.wait_for_timeout(2000)
            current_url = self.page.url
            
            # Verificar si ya est√° logueado (perfil persistente)
            if "asesores.segurossura.com.co" in current_url:
                self.logger.info("‚úÖ ¬°Ya est√°s logueado! (sesi√≥n activa desde perfil persistente)")
                self.logger.info(f"üìç URL actual: {current_url}")
                return True
            
            # Si no est√° logueado, esperar a que aparezcan los elementos de login
            await self.page.wait_for_selector(self.TIPO_DOCUMENTO_SELECT, timeout=10000)
            self.logger.info("‚úÖ P√°gina de login Sura cargada correctamente")
            return True
            
        except Exception as e:
            # Verificar una vez m√°s si ya est√° logueado por si hay un redirect lento
            current_url = self.page.url
            if "asesores.segurossura.com.co" in current_url:
                self.logger.info("‚úÖ ¬°Ya est√°s logueado! (detectado despu√©s de error inicial)")
                self.logger.info(f"üìç URL actual: {current_url}")
                return True
            
            self.logger.exception(f"‚ùå Error navegando a login Sura: {e}")
            return False

    async def select_tipo_documento(self, tipo: str = None) -> bool:
        """Selecciona el tipo de documento con reintentos autom√°ticos."""
        tipo_doc = tipo or self.config.TIPO_DOCUMENTO_LOGIN
        self.logger.info(f"üìã Seleccionando tipo de documento: {tipo_doc}")
        max_intentos = 5

        for intento in range(1, max_intentos + 1):
            try:
                self.logger.info(f"üîÑ Intento {intento}/{max_intentos} - Seleccionando tipo de documento")
                await self.page.select_option(self.TIPO_DOCUMENTO_SELECT, tipo_doc)
                await self.page.wait_for_timeout(500)
                if await self._verify_tipo_documento_selected(tipo_doc):
                    self.logger.info(f"‚úÖ Tipo de documento seleccionado correctamente: {tipo_doc}")
                    return True
                self.logger.warning(f"‚ö†Ô∏è Intento {intento} fall√≥")
                if intento < max_intentos:
                    await self.page.wait_for_timeout(1000)
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Error en intento {intento}: {e}")
                if intento < max_intentos:                    
                    await self.page.wait_for_timeout(1000)
                else:
                    self.logger.exception(f"‚ùå Error final seleccionando tipo de documento: {e}")

        self.logger.error(f"‚ùå No se pudo seleccionar el tipo de documento despu√©s de {max_intentos} intentos")
        return False

    async def _verify_tipo_documento_selected(self, expected_tipo: str) -> bool:
        """Verifica que el tipo de documento se haya seleccionado correctamente."""
        try:
            # Usar funci√≥n optimizada de la clase base
            return await self.verify_element_value_equals(
                selector=self.TIPO_DOCUMENTO_SELECT,
                expected_value=expected_tipo,
                property_name="value",
                description=f"Tipo de documento ({expected_tipo})"
            )
        except Exception as e:
            self.logger.error(f"‚ùå Error verificando tipo de documento: {e}")
            return False

    async def fill_virtual_keyboard_password(self, contrasena: str) -> bool:
        """Llena la contrase√±a usando el teclado virtual de Sura."""
        self.logger.info("üîê Llenando contrase√±a con teclado virtual...")
        try:
            await self.page.click(self.CONTRASENA_INPUT)
            self.logger.info("üì± Campo de contrase√±a activado")
            await self.page.wait_for_selector(self.VIRTUAL_KEYBOARD, timeout=Constants.SURA_KEYBOARD_APPEAR_TIMEOUT)
            self.logger.info("‚å®Ô∏è Teclado virtual detectado")
            self.logger.info("üîß Usando m√©todo JavaScript para teclado virtual...")
            if not await self._try_javascript_clicks(contrasena):
                self.logger.error("‚ùå M√©todo JavaScript fall√≥")
                return False
            if not await self._verify_password_length(contrasena):
                return False
            self.logger.info(f"‚úÖ Contrase√±a completa ingresada: {len(contrasena)} d√≠gitos")
            await self.page.click(self.KEYBOARD_ACCEPT)
            try:
                await self.page.wait_for_selector(self.VIRTUAL_KEYBOARD, state='hidden', timeout=Constants.SURA_KEYBOARD_HIDE_TIMEOUT)
            except:
                self.logger.warning("‚ö†Ô∏è Teclado virtual no se ocult√≥, continuando...")
            self.logger.info("üéâ Contrase√±a ingresada exitosamente")
            return True
        except Exception as e:
            self.logger.exception(f"‚ùå Error usando teclado virtual: {e}")
            return False

    async def _try_javascript_clicks(self, contrasena: str) -> bool:
        """Intenta hacer clic usando JavaScript con eventos completos de mouse (fallback)."""
        try:
            for i, digito in enumerate(contrasena):
                if not digito.isdigit():
                    self.logger.error("‚ùå Car√°cter inv√°lido en contrase√±a (solo n√∫meros permitidos)")
                    return False
                self.logger.info(f"üî¢ Haciendo clic JS {i+1}/{len(contrasena)}")
                result = await self.page.evaluate(self._CLICK_DIGIT_JS, digito)
                if not result:
                    self.logger.error("‚ùå No se pudo hacer clic en el bot√≥n del teclado")
                    return False
                await self.page.wait_for_timeout(Constants.SURA_CLICK_DELAY)
            return True
        except Exception as e:
            self.logger.error(f"‚ùå M√©todo JavaScript fall√≥: {e}")
            return False

    async def _verify_password_length(self, expected_password: str) -> bool:
        """Verifica que la contrase√±a tenga la longitud correcta."""
        try:
            current_value = await self._get_value(self.CONTRASENA_INPUT)
            if len(current_value) == len(expected_password):
                return True
            # Fallback: usar JS si fuera necesario
            current_value = await self.page.evaluate(self._GET_KEYBOARD_VALUE_JS)
            if len(current_value) != len(expected_password):
                self.logger.error(f"‚ùå Contrase√±a no coincide: esperado {len(expected_password)}, actual {len(current_value)}")
                return False
            return True
        except Exception as e:
            self.logger.error(f"‚ùå Error verificando longitud de contrase√±a: {e}")
            return False

    async def fill_credentials(self, usuario: str, contrasena: str) -> bool:
        """Llena las credenciales de login."""
        self.logger.info("üìù Llenando credenciales...")
        try:
            if not await self.safe_fill(self.NUMERO_DOCUMENTO_INPUT, usuario):
                self.logger.error("‚ùå Error llenando n√∫mero de documento")
                return False
            if not await self.fill_virtual_keyboard_password(contrasena):
                self.logger.error("‚ùå Error llenando contrase√±a")
                return False
            self.logger.info("‚úÖ Credenciales llenadas correctamente")
            return True
        except Exception as e:
            self.logger.exception(f"‚ùå Error llenando credenciales: {e}")
            return False

    async def verify_and_complete_form(self, usuario: str = None, contrasena: str = None) -> bool:
        """Verifica y completa autom√°ticamente los campos del formulario que est√©n vac√≠os."""
        self.logger.info("üîç Verificando y completando campos del formulario...")
        usuario = usuario or self.config.NUMERO_DOCUMENTO_LOGIN
        contrasena = contrasena or self.config.CONTRASENA_LOGIN
        form_complete = True
        try:
            # Tipo de documento
            tipo_actual = await self._get_value(self.TIPO_DOCUMENTO_SELECT)
            if not tipo_actual:
                self.logger.warning("‚ö†Ô∏è Tipo de documento no seleccionado, completando...")
                if not await self.select_tipo_documento():
                    form_complete = False
            else:
                self.logger.info(f"‚úÖ Tipo de documento ya seleccionado: {tipo_actual}")
            # N√∫mero de documento
            num_actual = await self.page.input_value(self.NUMERO_DOCUMENTO_INPUT)
            if not num_actual.strip():
                self.logger.warning("‚ö†Ô∏è N√∫mero de documento vac√≠o, completando...")
                if not await self.safe_fill(self.NUMERO_DOCUMENTO_INPUT, usuario):
                    form_complete = False
            else:
                self.logger.info(f"‚úÖ N√∫mero de documento ya ingresado: {num_actual}")
            # Contrase√±a
            if not await self._is_password_entered():
                self.logger.warning("‚ö†Ô∏è Contrase√±a no ingresada, completando...")
                if not await self.fill_virtual_keyboard_password(contrasena):
                    form_complete = False
            else:
                self.logger.info("‚úÖ Contrase√±a ya ingresada")
            return form_complete
        except Exception as e:
            self.logger.exception(f"‚ùå Error verificando formulario: {e}")
            return False

    async def complete_login_with_retries(self, usuario: str, contrasena: str, max_attempts: int = 3) -> bool:
        """Completa el login con reintentos autom√°ticos si el formulario est√° incompleto."""
        self.logger.info("üîÑ Iniciando login con reintentos autom√°ticos...")
        for attempt in range(1, max_attempts + 1):
            self.logger.info(f"üîÑ Intento de login {attempt}/{max_attempts}")
            try:
                if await self.verify_and_complete_form(usuario, contrasena):
                    if await self.safe_click(self.SUBMIT_BUTTON):
                        self.logger.info(f"‚úÖ Login enviado en intento {attempt}")
                        await self.page.wait_for_timeout(500)
                        return True
                    else:
                        self.logger.warning(f"‚ö†Ô∏è Error haciendo clic en submit (intento {attempt})")
                if attempt < max_attempts:
                    await self.page.wait_for_timeout(2000)
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Error en intento {attempt}: {e}")
                if attempt < max_attempts:
                    await self.page.wait_for_timeout(2000)
        self.logger.error(f"‚ùå No se pudo completar el login despu√©s de {max_attempts} intentos")
        return False

    async def verify_form_completion(self) -> bool:
        """Verifica que todos los campos del formulario est√©n completos antes de enviar."""
        self.logger.info("üîç Verificando que todos los campos est√©n completos...")
        try:
            if not await self._get_value(self.TIPO_DOCUMENTO_SELECT):
                self.logger.error("‚ùå Tipo de documento no seleccionado")
                return False
            if not (await self.page.input_value(self.NUMERO_DOCUMENTO_INPUT)).strip():
                self.logger.error("‚ùå N√∫mero de documento vac√≠o")
                return False
            if not await self._is_password_entered():
                self.logger.error("‚ùå Contrase√±a no ingresada")
                return False
            self.logger.info("üéØ Todos los campos verificados correctamente")
            return True
        except Exception as e:
            self.logger.exception(f"‚ùå Error verificando campos del formulario: {e}")
            return False

    async def submit_login(self, usuario: str = None, contrasena: str = None) -> bool:
        """Env√≠a el formulario de login, verificando y completando campos si es necesario."""
        self.logger.info("üöÄ Enviando formulario de login...")
        try:
            if not await self.verify_and_complete_form(usuario, contrasena):
                self.logger.error("‚ùå No se pudieron completar todos los campos")
                return False
            if not await self.safe_click(self.SUBMIT_BUTTON):
                self.logger.error("‚ùå Error haciendo clic en submit")
                return False
            await self.page.wait_for_timeout(500)
            self.logger.info("‚úÖ Formulario de login enviado")
            return True
        except Exception as e:
            self.logger.exception(f"‚ùå Error enviando formulario: {e}")
            return False

    async def verify_login_success(self) -> bool:
        """Verifica si el login fue exitoso, manejando MFA si es necesario."""
        self.logger.info("üîç Verificando login exitoso...")
        try:
            await self.page.wait_for_timeout(1000)
            current_url = self.page.url
            self.logger.info(f"üìç URL actual despu√©s del login: {current_url}")
            
            # Verificar si es login exitoso directo
            if "asesores.segurossura.com.co" in current_url:
                self.logger.info("‚úÖ Login verificado exitosamente")
                return True
            
            # Verificar si requiere MFA (autenticaci√≥n de dos factores)
            if "mfa/process" in current_url:
                self.logger.info("üîê Detectado MFA (autenticaci√≥n de dos factores)")
                return await self._handle_mfa()
            
            # Si no redirigi√≥, esperar 3 segundos m√°s y volver a verificar
            self.logger.info("‚è≥ A√∫n cargando, esperando 3 segundos m√°s...")
            await self.page.wait_for_timeout(3000)
            current_url = self.page.url
            self.logger.info(f"üìç URL despu√©s de espera adicional: {current_url}")
            
            if "asesores.segurossura.com.co" in current_url:
                self.logger.info("‚úÖ Login verificado exitosamente tras espera adicional")
                return True
            elif "mfa/process" in current_url:
                self.logger.info("üîê Detectado MFA tras espera adicional")
                return await self._handle_mfa()
                
            self.logger.error("‚ùå Login no exitoso - no se redirigi√≥ correctamente")
            return False
        except Exception as e:
            self.logger.exception(f"‚ùå Error verificando login: {e}")
            return False

    async def _handle_mfa(self) -> bool:
        """Maneja el proceso de autenticaci√≥n de dos factores con intervenci√≥n manual."""
        self.logger.info("üì± Iniciando proceso de MFA...")
        self.logger.info("‚è∏Ô∏è PAUSA PARA INTERVENCI√ìN MANUAL")
        self.logger.info("=" * 70)
        self.logger.info("üîî ACCI√ìN REQUERIDA:")
        self.logger.info("   1. Ingresa manualmente el c√≥digo MFA en el navegador")
        self.logger.info("   2. ¬°IMPORTANTE! Marca 'Recordar este dispositivo por 8 d√≠as'")
        self.logger.info("   3. Haz clic en 'Continuar' o 'Siguiente'")
        self.logger.info("   4. La automatizaci√≥n continuar√° autom√°ticamente")
        self.logger.info("")
        self.logger.info("üí° Esto evitar√° que se pida MFA en pr√≥ximas ejecuciones")
        self.logger.info("=" * 70)
        
        try:
            # Esperar hasta que la URL cambie o hasta 5 minutos m√°ximo
            max_wait_time = 300000  # 5 minutos
            check_interval = 2000   # Revisar cada 2 segundos
            elapsed_time = 0
            
            while elapsed_time < max_wait_time:
                await self.page.wait_for_timeout(check_interval)
                elapsed_time += check_interval
                current_url = self.page.url
                
                # Si ya no est√° en la p√°gina de MFA, verificar si lleg√≥ al dashboard
                if "mfa/process" not in current_url:
                    self.logger.info(f"üìç URL cambi√≥ a: {current_url}")
                    if "asesores.segurossura.com.co" in current_url:
                        self.logger.info("‚úÖ MFA completado exitosamente")
                        self.logger.info("üéâ Si marcaste 'recordar dispositivo', no volver√° a pedirse por 8 d√≠as")
                        return True
                    else:
                        self.logger.warning(f"‚ö†Ô∏è URL inesperada despu√©s de MFA: {current_url}")
                        # Dar una oportunidad m√°s
                        await self.page.wait_for_timeout(3000)
                        final_url = self.page.url
                        if "asesores.segurossura.com.co" in final_url:
                            self.logger.info("‚úÖ MFA completado exitosamente tras verificaci√≥n adicional")
                            self.logger.info("üéâ Si marcaste 'recordar dispositivo', no volver√° a pedirse por 8 d√≠as")
                            return True
                
                # Mostrar progreso cada 30 segundos
                if elapsed_time % 30000 == 0:
                    minutes_elapsed = elapsed_time // 60000
                    self.logger.info(f"‚è≥ Esperando intervenci√≥n manual... ({minutes_elapsed} min transcurridos)")
            
            self.logger.error("‚ùå Tiempo de espera agotado para MFA (5 minutos)")
            return False
            
        except Exception as e:
            self.logger.exception(f"‚ùå Error durante el proceso de MFA: {e}")
            return False

    async def login(self, usuario: str, contrasena: str) -> bool:
        """Realiza el proceso completo de login en Sura."""
        self.logger.info("üîë Iniciando proceso de login en Sura...")
        try:
            if not await self.navigate_to_login():
                return False
            
            # Verificar si ya est√° logueado despu√©s de navegar
            current_url = self.page.url
            if "asesores.segurossura.com.co" in current_url:
                self.logger.info("üéâ Ya est√°s logueado - omitiendo pasos de login")
                return True
            
            # Si no est√° logueado, proceder con el login normal
            if not await self.select_tipo_documento():
                return False
            if not await self.fill_credentials(usuario, contrasena):
                return False
            if not await self.submit_login(usuario, contrasena):
                self.logger.warning("‚ö†Ô∏è Fallo en submit_login, usando m√©todo con reintentos...")
                if not await self.complete_login_with_retries(usuario, contrasena):
                    return False
            if not await self.verify_login_success():
                return False
            self.logger.info("üéâ Login en Sura completado exitosamente")
            return True
        except Exception as e:
            self.logger.exception(f"‚ùå Error en proceso de login Sura: {e}")
            return False
